pip install openpyxl 
pip install lifetimes 
pip install xlrd 

import pandas as pd
import numpy as np
import datetime as dt
from lifetimes import BetaGeoFitter
from lifetimes import GammaGammaFitter
from sklearn.preprocessing import MinMaxScaler
from lifetimes.plotting import plot_probability_alive_matrix, plot_frequency_recency_matrix
from lifetimes.plotting import plot_calibration_purchases_vs_holdout_purchases, plot_period_transactions,plot_history_alive
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
pd.set_option('display.float_format', lambda x: '%.5f' % x) 



df = pd.read_excel('/kaggle/input/uci-online-retail-ii-data-set/online_retail_II.xlsx', sheet_name='Year 2010-2011')
df_ = df.copy() 



def check_df(dataframe):
    print("################ Shape ####################")
    print(dataframe.shape)
    print("############### Columns ###################")
    print(dataframe.columns)
    print("############### Types #####################")
    print(dataframe.dtypes)
    print("############### Head ######################")
    print(dataframe.head())
    print("############### Tail ######################")
    print(dataframe.tail())
    print("############### Describe ###################")
    print(dataframe.describe().T)

check_df(df) 



df.isnull().sum() 



df.dropna(inplace=True)
df.isnull().sum() 




def outlier_thresholds(dataframe, variable):
    quartile1 = dataframe[variable].quantile(0.01)
    quartile3 = dataframe[variable].quantile(0.99)
    interquantile_range = quartile3 - quartile1
    up_limit = quartile3 + 1.5 * interquantile_range
    low_limit = quartile1 - 1.5 * interquantile_range
    return low_limit, up_limit


def replace_with_thresholds(dataframe, variable):
    low_limit, up_limit = outlier_thresholds(dataframe, variable)
    dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit
    dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit 



df_uk = df[df['Country'] == 'United Kingdom'] 



df_uk = df_uk[~df_uk['Invoice'].str.contains('C', na=False)] 



df_uk = df_uk[df_uk['Price'] > 0] 



replace_with_thresholds(df_uk, 'Price')
replace_with_thresholds(df_uk, 'Quantity') 



df_uk.head() 



df_uk['TotalPrice'] = df_uk['Quantity'] * df_uk['Price'] 



df_uk[df_uk['Invoice'] == 536365] 



df_uk['InvoiceDate'].max() 



today_date = dt.datetime(2011, 12, 11) 



df.head() 



df.dtypes 



df_uk = df_uk.groupby('Customer ID').agg({'TotalPrice':'sum',
                              'InvoiceDate': [lambda date: (date.max()-date.min()).days,
                                              lambda date: (today_date - date.min()).days],
                              'Invoice': lambda Invoice: Invoice.nunique()}) 



df_uk.head() 



df_uk.columns.droplevel(0) 



df_uk.columns = ['monetary', 'recency', 'T', 'frequency'] 



df_uk.head() 



df_uk['monetary'] = df_uk['monetary'] / df_uk['frequency']
df_uk = df_uk[df_uk['frequency'] > 1]
df_uk['recency'] = df_uk['recency'] / 7
df_uk['T'] = df_uk['T'] / 7
bgf = BetaGeoFitter()
bgf.fit(df_uk['frequency'], df_uk['recency'], df_uk['T']) 



bgf.summary 



plot_period_transactions(bgf) 



bgf.conditional_expected_number_of_purchases_up_to_time(1, df_uk['frequency'], df_uk['recency'], df_uk['T']).sort_values(ascending=False).head(10) 



df_uk['expected_purch_6month'] = bgf.predict(4*6, df_uk['frequency'], df_uk['recency'], df_uk['T']) 



df_uk.sort_values(by='expected_purch_6month', ascending= False).head() 



ggf = GammaGammaFitter(penalizer_coef=0.01) 
ggf.fit(df_uk['frequency'], df_uk['monetary']) 



ggf.summary 



ggf.conditional_expected_average_profit(df_uk['frequency'], df_uk['monetary']).sort_values(ascending=False).head(10) 



#########
df_uk['expected_average_profit'] = ggf.conditional_expected_average_profit(df_uk['frequency'], df_uk['monetary'])
######### 

cltv = ggf.customer_lifetime_value(bgf, df_uk['frequency'], df_uk['recency'], df_uk['T'], df_uk['monetary'], time=6, freq='W') 

cltv = cltv.reset_index() 

cltv_final = df_uk.merge(cltv, on='Customer ID', how='left') 

cltv_final.sort_values(by='clv', ascending=False).head() 

scaler = MinMaxScaler(feature_range=(0, 1)) 

cltv_final.head() 

scaler.fit(cltv_final[['clv']]) 



cltv_final['scaled_cltv'] = scaler.transform(cltv_final[['clv']]) 

cltv_final.sort_values(by='scaled_cltv', ascending=False).head() 



cltv_final.sort_values(by='scaled_cltv', ascending=False).tail()
